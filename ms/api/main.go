package main

import (
	"log"
	"net/http"
	"os"
	"rest_api_go/handlers"

	"rest_api_go/middleware"
	"rest_api_go/repositories"
	"rest_api_go/services"

	"github.com/gorilla/mux"
	_ "github.com/lib/pq"

	_ "go.mongodb.org/mongo-driver/mongo/readpref" // Import readpref for MongoDB

	httpSwagger "github.com/swaggo/http-swagger/v2"

	"rest_api_go/docs" // docs is generated by Swag CLI, you have to import it.
)

func main() {

	db := initDB()

	// Create a new repository and service
	repo := repositories.NewDataRepository(db)
	deviceService := services.NewDataService(repo)

	// Inject the service into the handlers
	handlers.SetDataService(deviceService)

	userRepo := repositories.NewUserRepository(db)
	userService := services.NewUserService(userRepo)
	handlers.SetUserService(userService)

	defaultPort := "80"
	defaultTLSPort := "443"

	port := os.Getenv("PORT")
	if port == "" {
		port = defaultPort
	}

	tlsPort := os.Getenv("TLS_PORT")
	if tlsPort == "" {
		tlsPort = defaultTLSPort
	}

	certFile := os.Getenv("TLS_CERT_FILE")
	keyFile := os.Getenv("TLS_KEY_FILE")

	docs.SwaggerInfo.Title = "Example API"
	docs.SwaggerInfo.Description = "This is an awesome example API" // Update description
	docs.SwaggerInfo.Version = "1.0"
	docs.SwaggerInfo.Host = os.Getenv("API_HOST")        // Update host if needed
	docs.SwaggerInfo.BasePath = "/api/v1"                // Consistent base path
	docs.SwaggerInfo.Schemes = []string{"http", "https"} // Update schemes if needed

	r := mux.NewRouter()

	// Authentication routes (outside the API group)
	r.HandleFunc("/login", handlers.LoginHandler).Methods(http.MethodPost)
	r.HandleFunc("/users", handlers.RegisterUserHandler).Methods(http.MethodPost)

	// API version 1 group
	apiV1 := r.PathPrefix("/api/v1").Subrouter()
	apiV1.Use(middleware.JWTMiddleware)

	apiV1.HandleFunc("/users", handlers.RegisterUserHandler).Methods(http.MethodPost)            // Corrected: /users
	apiV1.HandleFunc("/users/{username}", handlers.RemoveUserHandler).Methods(http.MethodDelete) // Corrected: /users
	apiV1.HandleFunc("/data", handlers.GetDataHandler).Methods(http.MethodGet)
	apiV1.HandleFunc("/data/{id}", handlers.GetDataByIDHandler).Methods(http.MethodGet)
	apiV1.HandleFunc("/data", handlers.CreateDataHandler).Methods(http.MethodPost)
	apiV1.HandleFunc("/data/{id}", handlers.UpdateDataHandler).Methods(http.MethodPut)
	apiV1.HandleFunc("/data/{id}", handlers.PatchDataHandler).Methods(http.MethodPatch)
	apiV1.HandleFunc("/data/{id}", handlers.DeleteDataHandler).Methods(http.MethodDelete)

	// Swagger documentation (using relative URL)
	r.PathPrefix("/swagger/").Handler(httpSwagger.Handler(
		httpSwagger.URL("/swagger/doc.json"), // Relative URL is crucial
		httpSwagger.DeepLinking(true),
		httpSwagger.DocExpansion("none"),
		httpSwagger.DomID("swagger-ui"),
	)).Methods(http.MethodGet)

	// Conditional TLS Server
	if certFile != "" && keyFile != "" {
		go func() {
			log.Fatal(http.ListenAndServeTLS(":"+tlsPort, certFile, keyFile, r))
		}()

		log.Printf("Server listening on port %s (HTTP) and %s (HTTPS)", port, tlsPort)
	} else {
		log.Printf("Server listening on port %s (HTTP)", port)
	}

	log.Fatal(http.ListenAndServe(":"+port, r))
}
